#!/usr/bin/perl -w

sub compilation_rule($);
sub link_rule($$);

$prototypes_only = 0;
$absolute_pathnames_only = 0;

print <<eof;
# generated by $0 @ARGV
all: test_programs applications

eof

@files = ();
my $target_dir = 'binaries';
my $dependencies_from_map_file = 1;
while (@ARGV)  {
	my $arg = shift @ARGV;
	if ($arg eq "-prototypes_only") {
		$prototypes_only = 1;
	} elsif ($arg =~ /^-t/) {
		$target_dir = shift @ARGV or die;
		$target_dir =~ s/\/*$//;
	} elsif ($arg =~ /^-/) {
		die "$0: unknown argument '$arg'\n";
	} else {
		push @files, $arg;
	}
}

foreach $file (@files) {
	open F, $file or die "Can not open $file:$!\n";
	$source_dir_path = $file;
	$source_dir_path =~ s/[^\/]*$//;
	$source_dir_name = $source_dir_path;
	$source_dir_name =~ s/\/*$//;
	$source_dir_name =~ s/.*\///;
	my (@source_files, @library_members,@test_programs, @applications);
	@variable_assignments = ();
	while (<F>) {
		chomp;
		s/#.*//;
		s/^\s*//;
		s/\s*$//;
		next if !$_;
		s/^(source|application|test_program)s/$1/i;
		if (/^(source|application|test_program)\s*(.*)/i) {
			my ($type, $source_files) = ($1,$2);
			foreach $source_file (split /\s+/, $source_files) {
				my $full_source_file_pathname = "$source_dir_path$source_file";
#				print STDERR "push $file $full_source_file_pathname\n";
				push @source_files, $full_source_file_pathname;
				warn "$file:$. $full_source_file_pathname does not exist\n" if ! -e $full_source_file_pathname;
				next if $prototypes_only;
				$target = compilation_rule $full_source_file_pathname;
				$target = link_rule($target, $type) if $type =~ /application|test_program/;
				push @library_members, $target  if $type eq "source";
				push @test_programs, $target if $type eq "test_program";
				push @applications, $target if $type eq "application";
			}
		} elsif (/^(link\w+)\s*(.*)/i) {
			foreach $link (split /\s+/, $2) {
				push @link_flags, $link if !grep /^$link$/, @link_flags;
			}
		} elsif (/^!(.*)/) {
			print "$1\n";
		} elsif (/\=/) {
			push @variable_assignments, $_;
		} else {
			warn "$file:$. Unparsed line '$_'";
		}
	}
	close F;
#	print STDERR "$file @source_files\n";
	my $proto = "\$(TARGET_INCLUDES_DIR)/${source_dir_name}_prototypes.h";
	my $proto_updated = "\$(TARGET_INCLUDES_DIR)/.${source_dir_name}_prototypes.h.updated";
	print <<eof;
LIBRARY_MEMBERS += @library_members
TEST_PROGRAMS += @test_programs
APPLICATIONS += @applications
PROGRAM_SOURCE_FILES += @source_files
PROTOTYPES += $proto
SUB_DIRECTORIES += $target_dir/$source_dir_name

$proto: $proto_updated
$proto_updated: @source_files
	\@\$(EXTRACT_PROTOTYPES) -p $proto \$(GLOBAL_NAME_MAPPING) -n \$(TARGET_INCLUDES_DIR)/${source_dir_name}_name_mapping.h \$^
	\@touch $proto_updated
eof
}
print "LINK_FLAGS += @link_flags\n";
exit 0;

sub compilation_rule($) {
	my ($source_file) = @_;
	my $target = $source_file;
	$target =~ s/\//@/g;
	$target = "$target_dir/$target";
	$target =~ s/\.c$/.o/;
	my $dependencies = "";
	$dependencies = `gcc -I$source_dir_path -Iincludes -I$ENV{INCLUDES_PATH} -MM  $source_file|grep -v '^ */usr/'`;
	$dependencies =~ s/.*:\s*//;
	chomp $dependencies;
	my $d = "";
	$d = '$(TOP_DIR)/' if $absolute_pathnames_only;
	print "$target: $_\n" foreach @variable_assignments;
	print "$target: $d$source_file $dependencies\n";
	print "\t\@echo '\$\$(CC) -c $d$source_file -o $target'\n";
	print "\t\@\$(CC) -c $d$source_file -o $target\n";
	return $target;
}

sub link_rule($$) {
	my ($object, $type) = @_;
	my $target = $object;
	$target =~ s/\.o$//;
	$target =~ s/.*@//;
	my $brief_target = $target;
	$target = '$(TEST_PROGRAMS_DIR)/'.$target if $type eq "test_program";
	$target = '$(APPLICATIONS_DIR)/'.$target if $type eq "application";
	print "$brief_target:$target\n";
	print "$target: $_\n" foreach @variable_assignments;
	if (!$dependencies_from_map_file) {
		print "$target: $object \$(LIBRARY)\n";
		print "\t\@echo '\$\$(CC) $object -o $target \$\$(LINK_FLAGS)\n";
		print "\t\@\$(CC) $object -o $target \$(LINK_FLAGS)\n";
	} else {
		my $map_file = $object;
		$map_file =~ s/.*\///;
		$map_file =~ s/\.o$/.map/;
		$map_file = "$target_dir/$map_file";
		my $dependencies_file = $map_file;
		$dependencies_file =~ s/map$/dependencies/;
		# A dependencies file indicates which parts of the library a binary depends on
		# if we don't have one we have to re-make when any part of the library changes
		if (-s $dependencies_file) {
			print "$target: $object ".`cat $dependencies_file`."\n";
		} else {
			print "$target: $object \$(LIBRARY)\n";
		}
		print <<eof
	\@echo '\$\$(CC) $object -o $target \$\$(LINK_FLAGS)'
	\@if \$(CC) $object -Xlinker -cref -Xlinker -Map -Xlinker $map_file -o $target \$(LINK_FLAGS); \\
	then \\
		\$(EXTRACT_DEPENDENCIES_FROM_MAP_FILE) $target_dir $map_file >$dependencies_file; \\
	else \\
		rm $map_file $dependencies_file; \\
		\$(CC) $object -o $target \$(LINK_FLAGS); # work-around /usr/bin/ld -Map bug \\
	fi
eof
	}
	return $target;
}
