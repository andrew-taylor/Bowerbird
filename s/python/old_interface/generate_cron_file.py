#!/usr/bin/env python

# parse the config file to find times to record and then generate a crontab
# file that will cause those recordings to happen

# TODO error checking

# TODO add invoking of assemble_recording_files.py

import sys
from optparse import OptionParser
from bowerbird.scheduleparser import ScheduleParser

# location of configuration file
DEFAULT_USER = 'root' # the user to execute the command to put in crontab
DEFAULT_DAYS_TO_SCHEDULE = 7
DEFAULT_CONFIG_FILENAME = '../bowerbird_config'
DEFAULT_SCHEDULE_FILENAME = '../bowerbird_schedule'

# TODO search for this file in a number of places

if __name__ == '__main__':
    # parse commandline options
    parser = OptionParser()
    parser.add_option("-c", "--config", dest="config_filename",
            help="configuration file", default=DEFAULT_CONFIG_FILENAME)
    parser.add_option("-s", "--schedule", dest="schedule_filename",
            help="schedule file", default=DEFAULT_SCHEDULE_FILENAME)
    (options, args) = parser.parse_args()
    schedule = ScheduleParser(options.config_filename, options.schedule_filename)

    if not schedule.assertCommandIsDefined():
        sys.exit(1)
    if not schedule.user:
        schedule.user = DEFAULT_USER
    if not schedule.days_to_schedule:
        schedule.days_to_schedule = DEFAULT_DAYS_TO_SCHEDULE
    print '''# system crontab automatically generated by
# %s
# to schedule daily sound capturing.

# Do not edit directly as it will be overwritten

# use /bin/bash to run commands, instead of the default /bin/sh
SHELL=/bin/bash
# set path so we can find all commands
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

# m\th\tdom\tmon\tdow\tuser\tcommand''' % sys.argv[0]
    cron_times = []
    start = None
    finish = None
    for recording_time in schedule.getSchedules():
        if start == None:
            # new duration starting
            start, finish = recording_time.getStartAndFinish()
        else:
            if recording_time.start < finish:
                # if current overlaps previous times
                if recording_time.finish > finish:
                    # if it extends previous times
                    finish = recording_time.finish
            else:
                # no overlap so save current duration
                cron_times.append((start, finish))
                # initialise next duration
                start, finish = recording_time.getStartAndFinish()
    # save the last duration
    if start != None:
        cron_times.append((start, finish))
    
    for start,finish in cron_times:
        command_str = schedule.command % (finish - start).seconds
        print '%d\t%d\t%d\t%d\t*\t%s\t%s' % (start.minute, start.hour,
                start.day, start.month, schedule.user, command_str)
